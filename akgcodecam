#!/usr/bin/python

import codecs

# https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html

def read_file (filename, encoding = "utf8"):
    """Read entire file."""

    return codecs.open (filename, "r", encoding).read ()

lines = read_file("test.gcode").split("\n")

PRINTER_IGNORE = ["M190", "M104", "M109", "G21", "M82", "M107", "M117", "M205", "M140", "M106", "M84"]
MODE_ABS = "ABS"
MODE_REL = "REL"

class Pos():
    def __init__(self, x = None, y = None, z = None, e = None):
        self.x = x
        self.y = y
        self.z = z
        self.e = e

    def minus(self, other):
        # TODO: __minus__?
        return Delta(dx = self.x - other.x, dy = self.y - other.y, dz = self.z - other.z, de = self.e - other.e)

    def is_defined(self):
        return self.x != None and self.y != None and self.z != None and self.e != None

    def is_home(self):
        return self.x == 0 and self.y == 0 and self.z == 0

    def update(self, mode, dx = 0, dy = 0, dz = 0, de = 0):
        if mode == MODE_REL:
            return Pos(x = self.x + dx, y = self.y + dy, z = self.z + dz, e = self.e + de)
        elif mode == MODE_ABS:
            return Pos(x = float(dx), y = float(dy), z = float(dz), e = float(de))
        else:
            raise ValueError("Mode of operation is unknown: " + mode)

    def __str__(self):
        return "Pos(x = " + str(self.x) + ", y = " + str(self.y) + ", z = " + str(self.z) + ", e=" + str(self.e) + ")"

class Delta():
    def __init__(self, dx = 0, dy = 0, dz = 0, de = 0):
        self.dx = dx
        self.dy = dy
        self.dz = dz
        self.de = de

    def has_xyz_moves(self):
        return self.dx != 0 or self.dy != 0 and self.dz != 0

    def is_extrusion(self):
        return self.de > 0

    def is_retraction(self):
        return self.de < 0

    def __str__(self):
        s = "Delta("
        d = []
        if self.dx != 0: d.append("dx = " + str(self.dx))
        if self.dy != 0: d.append("dy = " + str(self.dy))
        if self.dz != 0: d.append("dz = " + str(self.dz))
        if self.de != 0: d.append("de = " + str(self.de))
        s += ", ".join(d)
        s += ")"
        return s

class Printer:
    def __init__(self):
        self.x = None
        self.y = None
        self.z = None
        self.e = None
        self.__mode = None

    def state(self):
        return "x:" + str(self.x) + " y:" + str(self.y) + " z:" + str(self.z) + " e:" + str(self.e) + " m:" + str(self.__mode)

    def handle(self, line):
        orig_line = line
        line = line.strip().upper()

        if line.startswith(";") or not line:
            return

        if " " in line:
            code, args = line.split(" ", 1)
        else:
            code = line
            args = ""

        def complain_parse(x):
            raise ValueError("What is '" + x + "'. No idea how to parse this line: " + orig_line)

        def strip_comment(s):
            return s.split(";", 1)[0]

        def parse_args():
            return [arg for arg in args and strip_comment(args).split(" ") or [] if arg != ""]

        if code in PRINTER_IGNORE:
            return
        elif code == "G90":
            # Absolute position mode
            self.__mode = MODE_ABS
        elif code == "G91":
            # Relative position mode
            self.__mode = MODE_REL
        elif code == "G28":
            # Home
            pargs = parse_args()
            if pargs == []:
                self.x = 0
                self.y = 0
                self.z = 0
            else:
                for arg in pargs:
                    if arg == "X" or arg == "X0":
                        self.x = 0
                    elif arg == "Y" or arg == "Y0":
                        self.y = 0
                    elif arg == "Z" or arg == "Z0":
                        self.z = 0
                    else:
                        complain_parse(arg)
        elif code == "G1" or code == "G01" or code == "G0" or code == "G00":
            # Move
            pargs = parse_args()

            for arg in pargs:
                def update(name, oldv):
                    v = float(arg[1:])
                    if self.__mode == MODE_ABS:
                        return v
                    elif self.__mode == MODE_REL:
                        return v + oldv
                    else:
                        raise ValueError("Mode of operation is not set at line: " + orig_line)

                if arg.startswith("X"):
                    self.x = update("X", self.x)
                elif arg.startswith("Y"):
                    self.y = update("Y", self.y)
                elif arg.startswith("Z"):
                    self.z = update("Z", self.z)
                elif arg.startswith("E"):
                    self.e = update("E", self.e)
                elif arg.startswith("F"):
                    pass
                else:
                    complain_parse(arg)
        elif code == "G92":
            # Set position (no physical move)
            pargs = parse_args()

            for arg in pargs:
                if arg.startswith("X"):
                    self.x = float(arg[1:])
                elif arg.startswith("Y"):
                    self.y = float(arg[1:])
                elif arg.startswith("Z"):
                    self.z = float(arg[1:])
                elif arg.startswith("E"):
                    self.e = float(arg[1:])
                else:
                    complain_parse(arg)
        else:
            raise ValueError("Unknown G-Code: " + code)

class EventDetector(object):
    def __init__(self, printer):
        self._printer = printer
        self.__initialized = False

    def handle(self, line):
        oldx = self._printer.x
        oldy = self._printer.y
        oldz = self._printer.z
        olde = self._printer.e

        self._printer.handle(line)

        if self.__initialized:
            changex = self._printer.x - oldx
            changey = self._printer.y - oldy
            changez = self._printer.z - oldz
            changee = self._printer.e - olde
            if changex != 0 or changey != 0 or changez != 0:
                if changee == 0:
                    self.on_move(oldx, oldy, oldz, changex, changey, changez)
                elif changee > 0:
                    self.on_print(oldx, oldy, oldz, olde, changex, changey, changez, changee)
                else:
                    self.on_retract_move(oldx, oldy, oldz, olde, changex, changey, changez, changee)
            else:
                if changee > 0:
                    self.on_extrude(olde, changee)
                elif changee < 0:
                    self.on_retract(olde, changee)
        else:
            # Was not initialized, check now
            if self._printer.x != None and self._printer.y != None and self._printer.z != None and self._printer.e != None:
                self.__initialized = True
                self.on_init()

    def on_init():
        pass

    def on_move(self, oldx, oldy, oldz, changex, changey, changez):
        pass

    def on_print(self, oldx, oldy, oldz, olde, changex, changey, changez, changee):
        pass

    def on_retract_move(self, oldx, oldy, oldz, olde, changex, changey, changez, changee):
        pass

    def on_extrude(self, olde, changee):
        pass

    def on_retract(self, olde, changee):
        pass

printer = Printer()

class CamEventDetector(EventDetector):
    def __init__(self, printer):
        super(self.__class__, self).__init__(printer)

    def on_init(self):
        print("Initialized.   State" + self._printer.state())

    def on_move(self, oldx, oldy, oldz, changex, changey, changez):
        print("Moved." + "TODO" + "   New state: " + self._printer.state())

    def on_print(self, oldx, oldy, oldz, olde, changex, changey, changez, changee):
        print("Printed.   New state: " + self._printer.state())

    def on_retract_move(self, oldx, oldy, oldz, olde, changex, changey, changez, changee):
        print("Moved and retracted.   New state: " + self._printer.state())

    def on_extrude(self, olde, changee):
        print("Extruded.   New state: " + self._printer.state())

    def on_retract(self, olde, changee):
        print("Retracted.   New state: " + self._printer.state())

event_detector = CamEventDetector(printer)

for line in lines:
    event_detector.handle(line)
