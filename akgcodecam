#!/usr/bin/python

import codecs

# https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html

def read_file (filename, encoding = "utf8"):
    """Read entire file."""

    return codecs.open (filename, "r", encoding).read ()

lines = read_file("test.gcode").split("\n")

PRINTER_IGNORE = ["M190", "M104", "M109", "G21", "M82", "M107", "M117", "M205", "M140", "M106", "M84"]
MODE_ABS = "ABS"
MODE_REL = "REL"

class Pos:
    def __init__(self, x = None, y = None, z = None, e = None):
        self.x = x
        self.y = y
        self.z = z
        self.e = e

    def subtract(self, other):
        return Delta(dx = self.x - other.x, dy = self.y - other.y, dz = self.z - other.z, de = self.e - other.e)

    def is_defined(self):
        return self.x != None and self.y != None and self.z != None and self.e != None

    def is_home(self):
        return self.x == 0 and self.y == 0 and self.z == 0

    def copy(self, x = None, y = None, z = None, e = None):
        return self.update(MODE_ABS, dx = x, dy = y, dz = z, de = e)

    def update(self, mode, dx = None, dy = None, dz = None, de = None):
        if mode == MODE_REL:
            nx = dx != None and (self.x + dx) or self.x
            ny = dy != None and (self.y + dy) or self.y
            nz = dz != None and (self.z + dz) or self.z
            ne = de != None and (self.e + de) or self.e
            return Pos(x = nx, y = ny, z = nz, e = ne)
        elif mode == MODE_ABS:
            nx = dx != None and dx or self.x
            ny = dy != None and dy or self.y
            nz = dz != None and dz or self.z
            ne = de != None and de or self.e
            return Pos(x = nx, y = ny, z = nz, e = ne)
        else:
            raise ValueError("Mode of operation is unknown: " + mode)

    def __str__(self):
        return "Pos(x = " + str(self.x) + ", y = " + str(self.y) + ", z = " + str(self.z) + ", e=" + str(self.e) + ")"

class Delta:
    def __init__(self, dx = 0, dy = 0, dz = 0, de = 0):
        self.dx = dx
        self.dy = dy
        self.dz = dz
        self.de = de

    def has_xyz_moves(self):
        return self.dx != 0 or self.dy != 0 and self.dz != 0

    def is_extrusion(self):
        return self.de > 0

    def is_retraction(self):
        return self.de < 0

    def __str__(self):
        s = "Delta("
        d = []
        if self.dx != 0: d.append("dx = " + str(self.dx))
        if self.dy != 0: d.append("dy = " + str(self.dy))
        if self.dz != 0: d.append("dz = " + str(self.dz))
        if self.de != 0: d.append("de = " + str(self.de))
        s += ", ".join(d)
        s += ")"
        return s

class Printer:
    def __init__(self):
        self.pos = Pos()
        self.__mode = None

    def state(self):
        return str(self.pos) + " m:" + str(self.__mode)

    def handle(self, line):
        orig_line = line
        line = line.strip().upper()

        if line.startswith(";") or not line:
            return

        if " " in line:
            code, args = line.split(" ", 1)
        else:
            code = line
            args = ""

        def complain_parse(x):
            raise ValueError("What is '" + x + "'. No idea how to parse this line: " + orig_line)

        def strip_comment(s):
            return s.split(";", 1)[0]

        def parse_args():
            return [arg for arg in args and strip_comment(args).split(" ") or [] if arg != ""]

        if code in PRINTER_IGNORE:
            return
        elif code == "G90":
            # Absolute position mode
            self.__mode = MODE_ABS
        elif code == "G91":
            # Relative position mode
            self.__mode = MODE_REL
        elif code == "G28":
            # Home
            pargs = parse_args()
            if pargs == []:
                self.pos = self.pos.copy(x = 0, y = 0, z = 0)
            else:
                for arg in pargs:
                    if arg == "X" or arg == "X0":
                        self.pos = self.pos.copy(x = 0)
                    elif arg == "Y" or arg == "Y0":
                        self.pos = self.pos.copy(y = 0)
                    elif arg == "Z" or arg == "Z0":
                        self.pos = self.pos.copy(z = 0)
                    else:
                        complain_parse(arg)
        elif code == "G1" or code == "G01" or code == "G0" or code == "G00":
            # Move
            pargs = parse_args()

            for arg in pargs:
                if arg.startswith("X"):
                    self.pos = self.pos.update(self.__mode, dx = float(arg[1:]))
                elif arg.startswith("Y"):
                    self.pos = self.pos.update(self.__mode, dy = float(arg[1:]))
                elif arg.startswith("Z"):
                    self.pos = self.pos.update(self.__mode, dz = float(arg[1:]))
                elif arg.startswith("E"):
                    self.pos = self.pos.update(self.__mode, de = float(arg[1:]))
                elif arg.startswith("F"):
                    pass
                else:
                    complain_parse(arg)
        elif code == "G92":
            # Set position (no physical move)
            pargs = parse_args()

            for arg in pargs:
                if arg.startswith("X"):
                    self.pos = self.pos.copy(x = float(arg[1:]))
                elif arg.startswith("Y"):
                    self.pos = self.pos.copy(y = float(arg[1:]))
                elif arg.startswith("Z"):
                    self.pos = self.pos.copy(z = float(arg[1:]))
                elif arg.startswith("E"):
                    self.pos = self.pos.copy(e = float(arg[1:]))
                else:
                    complain_parse(arg)
        else:
            raise ValueError("Unknown G-Code: " + code)

class EventDetector(object):
    def __init__(self, printer):
        self._printer = printer
        self.__initialized = False

    def handle(self, line):
        oldp = self._printer.pos

        self._printer.handle(line)

        if self.__initialized:
            delta = self._printer.pos.subtract(oldp)

            if delta.has_xyz_moves():
                if delta.is_extrusion():
                    self.on_print(oldp, delta)
                elif delta.is_retraction():
                    self.on_retract_move(oldp, delta)
                else:
                    self.on_move(oldp, delta)
            else:
                if delta.is_extrusion():
                    self.on_extrude(oldp, delta)
                elif delta.is_retraction():
                    self.on_retract(oldp, delta)
                else:
                    pass # nothing
        else:
            # Was not initialized, check now
            if self._printer.pos.is_defined():
                self.__initialized = True
                self.on_init()

    def on_init():
        pass

    def on_move(self, oldp, delta):
        pass

    def on_print(self, oldp, delta):
        pass

    def on_retract_move(self, oldp, delta):
        pass

    def on_extrude(self, oldp, delta):
        pass

    def on_retract(self, oldp, delta):
        pass

class CamEventDetector(EventDetector):
    def __init__(self, printer):
        super(self.__class__, self).__init__(printer)

    def on_init(self):
        print("Initialized.   State" + self._printer.state())

    def on_move(self, oldp, delta):
        print("Moved. " + str(delta) + "   New state: " + self._printer.state())

    def on_print(self, oldp, delta):
        print("Printed. " + str(delta) + "   New state: " + self._printer.state())

    def on_retract_move(self, oldp, delta):
        print("Moved and retracted. " + str(delta) + "   New state: " + self._printer.state())

    def on_extrude(self, oldp, delta):
        print("Extruded. " + str(delta) + "   New state: " + self._printer.state())

    def on_retract(self, oldp, delta):
        print("Retracted. " + str(delta) + "   New state: " + self._printer.state())

# ####################################################################

printer = Printer()
event_detector = CamEventDetector(printer)

for line in lines:
    event_detector.handle(line)
